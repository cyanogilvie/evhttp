/* Generated by re2c 2.2 on Sun Nov 28 21:25:08 2021 */

struct con_state {
	enum con_role		role;

	uint64_t			accept_time;	// The first moment we became aware of the connection (nanoseconds resolution, cputime since process start)

	// Valid for requests
	enum ev_methods		method;
	unsigned char*		custom_method;
	struct cookie*		cookies;

	// Valid for responses
	unsigned char		status_code[4];
	int					status_numeric;
	struct set_cookie*	set_cookies;

	// Valid for both requests and responses
	int					connectionflags;
	struct headers		headers;
	struct obstack*		ob;				// Storage for the life of this message, not accessed directly
	struct obstack*		logs;
	struct log*			logs_head;
	struct log*			logs_tail;
	uint64_t			last_log;
	unsigned char*		http_ver;
	enum body_len		body_len;		// How to determine the message body length
	unsigned char*		body;
	size_t				body_avail;		// How many bytes are allocated at *body
	size_t				body_size;		// How many bytes are valid at *body
	enum body_storage	body_storage;
	int					body_fd;		// tmpfile fd if body_storage == BODY_STORAGE_MMAP
	ssize_t				chunk_remain;

	// Lexer state
	unsigned char*		cur;
	unsigned char*		mar;
	unsigned char*		tok;
	unsigned char*		lim;
	int					cond;
	int					state;
	enum con_status		status;
	struct mtagpool		mtp;
	
#line 46 "msg.h"
	unsigned char*		yyt1;
	unsigned char*		yyt11;
	unsigned char*		yyt2;
	unsigned char*		yyt3;
	unsigned char*		yyt4;
	unsigned char*		yyt5;
	unsigned char*		yyt6;
	unsigned char*		yyt7;
#line 47 "msg.re"

	
#line 58 "msg.h"
	struct mtag			*yytm10;
	struct mtag			*yytm12;
	struct mtag			*yytm13;
	struct mtag			*yytm14;
	struct mtag			*yytm15;
	struct mtag			*yytm16;
	struct mtag			*yytm17;
	struct mtag			*yytm3;
	struct mtag			*yytm4;
	struct mtag			*yytm5;
	struct mtag			*yytm6;
	struct mtag			*yytm7;
	struct mtag			*yytm8;
	struct mtag			*yytm9;
#line 48 "msg.re"

	size_t				buf_size;
	unsigned char*		buf;
};

void shift_msg_buffer(struct con_state* c, size_t shift);
void init_msg_buffer(struct con_state* c);
enum con_status parse_http_message(struct con_state* c);

enum msg_cond_type {
	yycstatusline,
	yycreqline,
	yycreqline_target,
	yycheader,
	yyctrailer,
	yyccontentlength,
	yycte,
	yycte_accept,
	yyccookie_av,
	yyccookie_av_end,
	yyccookie,
	yyccookie_end,
	yycconnection,
	yychost,
	yycheader_field_value,
	yyctrailer_field_value,
	yycchunk,
	yycchunk_bytes,
	yycchunk_end,
};
